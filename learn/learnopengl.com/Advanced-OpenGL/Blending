

<!DOCTYPE html>
<html lang="en"> 
<head>
    <meta charset="utf-8"/>
    <title>LearnOpenGL - Blending</title>	<!--<title>Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</title>-->
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"  />
    <meta name="description" content="Learn OpenGL . com provides good and clear modern 3.3+ OpenGL tutorials with clear examples. A great resource to learn modern OpenGL aimed at beginners.">
	<meta name="fragment" content="!">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-51879160-1', 'learnopengl.com');
      ga('send', 'pageview');

    </script>
    <!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-7855791439695850",
              enable_page_level_ads: true
         });
    </script>
	<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
	<script>
	  var googletag = googletag || {};
	  googletag.cmd = googletag.cmd || [];
	</script>
	<script>
	  googletag.cmd.push(function() {
		googletag.defineSlot('/8491498/learnopengl_video', [300, 225], 'div-gpt-ad-1540574378241-0').addService(googletag.pubads());
		googletag.pubads().enableSingleRequest();
		googletag.pubads().collapseEmptyDivs();
		googletag.enableServices();
	  });
	</script>
    <script type="text/javascript" src="//cdn.thisiswaldo.com/static/js/1681.js"></script>
	<script src="/js/jquery-1.11.0.min.js"></script>
	<script src="/js/hoverintent.js"></script>
	<link rel="stylesheet" type="text/css" href="/layout.css">
    <link rel="stylesheet" type="text/css" href="/js/styles/obsidian.css">
    <script src="/js/highlight.pack.js"></script>    
    <script src="/js/functions.js"></script>
    <script type="text/javascript" src="/js/mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
    <script>
    // Has to be loaded last due to content bug 
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>  
        $(document).ready(function() {
            // check if user visited from the old # based urls, re-direct to ?p= form
            if(window.location.hash)
            {
                var name = window.location.hash.substring(2);
                // name = name.replace(/-/g," ");
                var index = name.indexOf('#'); // Remove any hash fragments from the url (Disquss adds hash fragments for comments, but results in 404 pages)
                if(index >= 0)
                    name = name.substring(0, index);
                
                window.location.href = "https://learnopengl.com/" + name;
            } else {
                    // Check if data has been succesfully loaded, if so: change title bar as ajax hash fragment
                    var title = $('#content-url').text();
                  
                    // Refresh syntax highlighting
                    // $('pre').each(function(i, e) {hljs.highlightBlock(e)});
                  
                    // Reset DISQUS
                    // if(title == '/dev/')
                        // title = '';
                    // alert('hoi');
					
					// place video tag
					if(title != '') {
						var videoad = "%3Cdiv id=\'waldo-tag-12074\'%3E %3Cscript%3Egoogletag.cmd.push(function() {googletag.display(\'waldo-tag-12074\'); }); %3C/script%3E%3C/div%3E";
						$('#content p:nth-of-type(3)').after(unescape(videoad));
					}
					
                    // Adjust ads for correct bottom positioning based on content size
                    window.setTimeout(function() {  
                        AdPositioning();
                     }, 3000);
                  
                  
                    // set API resets after time-out (once content is properly loaded)
                    window.setTimeout(function() {  
                        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);       
                        MathJax.Hub.Queue(["resetEquationNumbers", MathJax.InputJax.TeX]);
                        
                        var page_url = title == "" ? "http://www.learnopengl.com/" : "http://www.learnopengl.com/" + title;
                        if(typeof DISQUS !== 'undefined') {                                              
                            DISQUS.reset({
                              reload: true,
                              config: function () {  
                                this.page.identifier = title;  
                                this.page.url = page_url;
                              }
                            });
                            $('#disqus_thread').show();
                        }
                           // Refresh callbacks on <function> tags
                        SetFunctionTagCallbacks();        
                    }, 1000);
                                        
                    // Zet ook de juiste button op 'selected'
                    $('#nav li span, #nav li a').removeClass('selected');                
                    if(title != '')
                    {                    
                        $('#nav li[id=\'' + title + '\']').children('span, a').addClass('selected');
                    }
                    // En open menu waar nodig
                    var parents = $('#nav span.selected, #nav a.selected').parents('li').children('span.closed, a.closed');
                    var index = 0;
                    for(index = parents.length - 1; index >= 0; index--)
                    {             
                        
                        var id = $(parents[index]).attr("id").replace( /^\D+/g, '');
                        MenuClick(id, false);
                    }                          
                
            }
        });
		// var initialized = false;
        // window.onpopstate = function() {
            // if(initialized)
                // LoadPage();
			// else
				// initialized = true;
        // };
        
        // Set up DISQUS
        // $(document).ready(function() {
            var disqus_shortname = 'learnopengl';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();           
        // });
    </script>
</head>
<body>
<a href="https://learnopengl.com">
<div id="header">
</div>
</a>

<div id="supercontainer">
    <!-- 728x90/320x50 -->
    <div id="header_ad">
        <div id="waldo-tag-6194"></div>
    </div>
    <div id="rightad_container">
        <div id="rightad">
            <!-- /8491498/learnopengl_video -->
            <!--<div id='div-gpt-ad-1540574378241-0' style='height:225px; width:300px;'>
			<script>
			googletag.cmd.push(function() { googletag.display('div-gpt-ad-1540574378241-0'); });
			</script>
			</div>            
            <br/>-->
			<!-- place in-content -->
			<!--<div id='waldo-tag-12074'>
			 <script>
			   googletag.cmd.push(function() { googletag.display('waldo-tag-12074'); });
			 </script>
			</div>-->
           
            <div id="waldo-tag-1715"></div>
        </div>

        <div id="admessage">
            If you're running AdBlock, please consider whitelisting this site if you'd like to support LearnOpenGL; and no worries, I won't be mad if you don't :)
            <!--<br/><br/>
            Also, check out this little local multiplayer-only game I've made: <a href="https://store.steampowered.com/app/983590/Tank_Blazers/" target="_blank">Tank Blazers</a>.
            <br/>
            <a href="https://store.steampowered.com/app/983590/Tank_Blazers" target="_blank"><img src="/img/tank_blazers.jpg"  style="width:278px; margin-top: 9px; margin-left: -3px;"/></a>-->
        </div>
        
        <div id="rightonethirdad">
            <div id="waldo-tag-2246"></div>
        </div>
        
        <div id="rightbottomad">            
			<div id="waldo-tag-2247"></div>								
        </div>
    </div>
    <div id="container">
        <div id="loading"></div>
<script> 
$(document).ready(function() {
$('#menu-item4').mousedown(function() { MenuClick(4, true) });
$('#menu-item48').mousedown(function() { MenuClick(48, true) });
$('#menu-item56').mousedown(function() { MenuClick(56, true) });
$('#menu-item63').mousedown(function() { MenuClick(63, true) });
$('#menu-item100').mousedown(function() { MenuClick(100, true) });
$('#menu-item102').mousedown(function() { MenuClick(102, true) });
$('#menu-item113').mousedown(function() { MenuClick(113, true) });
$('#menu-item116').mousedown(function() { MenuClick(116, true) });
$('#menu-item78').mousedown(function() { MenuClick(78, true) });
$('#menu-item81').mousedown(function() { MenuClick(81, true) });
$('#menu-item85').mousedown(function() { MenuClick(85, true) });
$('#menu-item125').mousedown(function() { MenuClick(125, true) });
$('#menu-item128').mousedown(function() { MenuClick(128, true) });
$('#menu-item129').mousedown(function() { MenuClick(129, true) });
$('#menu-item133').mousedown(function() { MenuClick(133, true) });
$('#menu-item134').mousedown(function() { MenuClick(134, true) });
$('#menu-item138').mousedown(function() { MenuClick(138, true) });
}); 
</script>   
    <div id="nav">
         <div id="social">
            <a href="https://github.com/JoeyDeVries/LearnOpenGL" target="_blank">
                    <img src="/img/github.png" class="social_ico">
            </a>
             <!-- <a href="https://www.facebook.com/Learnopengl-2199631333595544/" target="_blank">
                <img src="/img/facebook.png" class="social_ico">
            </a>-->
            <a href="https://twitter.com/JoeyDeVriez" target="_blank">
                <img src="/img/twitter.png" class="social_ico">
            </a>
          
        </div>
    <img src='img/nav-button_bottom-arrow.png' style='display: none'><ol><li id='Introduction'><a id="menu-item1" href="https://learnopengl.com/Introduction">Introduction </a></li><li id='Getting-started'><span id="menu-item4" class="closed">Getting started </span><ol id="menu-items-of4" style="display:none;"><li id='Getting-started/OpenGL'><a id="menu-item49" href="https://learnopengl.com/Getting-started/OpenGL">OpenGL </a></li><li id='Getting-started/Creating-a-window'><a id="menu-item5" href="https://learnopengl.com/Getting-started/Creating-a-window">Creating a window </a></li><li id='Getting-started/Hello-Window'><a id="menu-item6" href="https://learnopengl.com/Getting-started/Hello-Window">Hello Window </a></li><li id='Getting-started/Hello-Triangle'><a id="menu-item38" href="https://learnopengl.com/Getting-started/Hello-Triangle">Hello Triangle </a></li><li id='Getting-started/Shaders'><a id="menu-item39" href="https://learnopengl.com/Getting-started/Shaders">Shaders </a></li><li id='Getting-started/Textures'><a id="menu-item40" href="https://learnopengl.com/Getting-started/Textures">Textures </a></li><li id='Getting-started/Transformations'><a id="menu-item43" href="https://learnopengl.com/Getting-started/Transformations">Transformations </a></li><li id='Getting-started/Coordinate-Systems'><a id="menu-item44" href="https://learnopengl.com/Getting-started/Coordinate-Systems">Coordinate Systems </a></li><li id='Getting-started/Camera'><a id="menu-item47" href="https://learnopengl.com/Getting-started/Camera">Camera </a></li><li id='Getting-started/Review'><a id="menu-item50" href="https://learnopengl.com/Getting-started/Review">Review </a></li></ol></li><li id='Lighting'><span id="menu-item48" class="closed">Lighting </span><ol id="menu-items-of48" style="display:none;"><li id='Lighting/Colors'><a id="menu-item51" href="https://learnopengl.com/Lighting/Colors">Colors </a></li><li id='Lighting/Basic-Lighting'><a id="menu-item52" href="https://learnopengl.com/Lighting/Basic-Lighting">Basic Lighting </a></li><li id='Lighting/Materials'><a id="menu-item53" href="https://learnopengl.com/Lighting/Materials">Materials </a></li><li id='Lighting/Lighting-maps'><a id="menu-item54" href="https://learnopengl.com/Lighting/Lighting-maps">Lighting maps </a></li><li id='Lighting/Light-casters'><a id="menu-item55" href="https://learnopengl.com/Lighting/Light-casters">Light casters </a></li><li id='Lighting/Multiple-lights'><a id="menu-item58" href="https://learnopengl.com/Lighting/Multiple-lights">Multiple lights </a></li><li id='Lighting/Review'><a id="menu-item57" href="https://learnopengl.com/Lighting/Review">Review </a></li></ol></li><li id='Model-Loading'><span id="menu-item56" class="closed">Model Loading </span><ol id="menu-items-of56" style="display:none;"><li id='Model-Loading/Assimp'><a id="menu-item59" href="https://learnopengl.com/Model-Loading/Assimp">Assimp </a></li><li id='Model-Loading/Mesh'><a id="menu-item60" href="https://learnopengl.com/Model-Loading/Mesh">Mesh </a></li><li id='Model-Loading/Model'><a id="menu-item61" href="https://learnopengl.com/Model-Loading/Model">Model </a></li></ol></li><li id='Advanced-OpenGL'><span id="menu-item63" class="closed">Advanced OpenGL </span><ol id="menu-items-of63" style="display:none;"><li id='Advanced-OpenGL/Depth-testing'><a id="menu-item72" href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth testing </a></li><li id='Advanced-OpenGL/Stencil-testing'><a id="menu-item73" href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">Stencil testing </a></li><li id='Advanced-OpenGL/Blending'><a id="menu-item74" href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending </a></li><li id='Advanced-OpenGL/Face-culling'><a id="menu-item77" href="https://learnopengl.com/Advanced-OpenGL/Face-culling">Face culling </a></li><li id='Advanced-OpenGL/Framebuffers'><a id="menu-item65" href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">Framebuffers </a></li><li id='Advanced-OpenGL/Cubemaps'><a id="menu-item66" href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Cubemaps </a></li><li id='Advanced-OpenGL/Advanced-Data'><a id="menu-item69" href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">Advanced Data </a></li><li id='Advanced-OpenGL/Advanced-GLSL'><a id="menu-item67" href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL">Advanced GLSL </a></li><li id='Advanced-OpenGL/Geometry-Shader'><a id="menu-item68" href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader </a></li><li id='Advanced-OpenGL/Instancing'><a id="menu-item70" href="https://learnopengl.com/Advanced-OpenGL/Instancing">Instancing </a></li><li id='Advanced-OpenGL/Anti-Aliasing'><a id="menu-item75" href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">Anti Aliasing </a></li></ol></li><li id='Advanced-Lighting'><span id="menu-item100" class="closed">Advanced Lighting </span><ol id="menu-items-of100" style="display:none;"><li id='Advanced-Lighting/Advanced-Lighting'><a id="menu-item101" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">Advanced Lighting </a></li><li id='Advanced-Lighting/Gamma-Correction'><a id="menu-item110" href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction </a></li><li id='Advanced-Lighting/Shadows'><span id="menu-item102" class="closed">Shadows </span><ol id="menu-items-of102" style="display:none;"><li id='Advanced-Lighting/Shadows/Shadow-Mapping'><a id="menu-item103" href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">Shadow Mapping </a></li><li id='Advanced-Lighting/Shadows/Point-Shadows'><a id="menu-item104" href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">Point Shadows </a></li></ol></li><li id='Advanced-Lighting/Normal-Mapping'><a id="menu-item106" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">Normal Mapping </a></li><li id='Advanced-Lighting/Parallax-Mapping'><a id="menu-item107" href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">Parallax Mapping </a></li><li id='Advanced-Lighting/HDR'><a id="menu-item111" href="https://learnopengl.com/Advanced-Lighting/HDR">HDR </a></li><li id='Advanced-Lighting/Bloom'><a id="menu-item112" href="https://learnopengl.com/Advanced-Lighting/Bloom">Bloom </a></li><li id='Advanced-Lighting/Deferred-Shading'><a id="menu-item108" href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Deferred Shading </a></li><li id='Advanced-Lighting/SSAO'><a id="menu-item109" href="https://learnopengl.com/Advanced-Lighting/SSAO">SSAO </a></li></ol></li><li id='PBR'><span id="menu-item113" class="closed">PBR </span><ol id="menu-items-of113" style="display:none;"><li id='PBR/Theory'><a id="menu-item114" href="https://learnopengl.com/PBR/Theory">Theory </a></li><li id='PBR/Lighting'><a id="menu-item115" href="https://learnopengl.com/PBR/Lighting">Lighting </a></li><li id='PBR/IBL'><span id="menu-item116" class="closed">IBL </span><ol id="menu-items-of116" style="display:none;"><li id='PBR/IBL/Diffuse-irradiance'><a id="menu-item117" href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">Diffuse irradiance </a></li><li id='PBR/IBL/Specular-IBL'><a id="menu-item118" href="https://learnopengl.com/PBR/IBL/Specular-IBL">Specular IBL </a></li></ol></li></ol></li><li id='In-Practice'><span id="menu-item78" class="closed">In Practice </span><ol id="menu-items-of78" style="display:none;"><li id='In-Practice/Debugging'><a id="menu-item79" href="https://learnopengl.com/In-Practice/Debugging">Debugging </a></li><li id='In-Practice/Text-Rendering'><a id="menu-item80" href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering </a></li><li id='In-Practice/2D-Game'><span id="menu-item81" class="closed">2D Game </span><ol id="menu-items-of81" style="display:none;"><li id='In-Practice/2D-Game/Breakout'><a id="menu-item82" href="https://learnopengl.com/In-Practice/2D-Game/Breakout">Breakout </a></li><li id='In-Practice/2D-Game/Setting-up'><a id="menu-item88" href="https://learnopengl.com/In-Practice/2D-Game/Setting-up">Setting up </a></li><li id='In-Practice/2D-Game/Rendering-Sprites'><a id="menu-item83" href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites">Rendering Sprites </a></li><li id='In-Practice/2D-Game/Levels'><a id="menu-item84" href="https://learnopengl.com/In-Practice/2D-Game/Levels">Levels </a></li><li id='In-Practice/2D-Game/Collisions'><span id="menu-item85" class="closed">Collisions </span><ol id="menu-items-of85" style="display:none;"><li id='In-Practice/2D-Game/Collisions/Ball'><a id="menu-item95" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Ball">Ball </a></li><li id='In-Practice/2D-Game/Collisions/Collision-detection'><a id="menu-item96" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection">Collision detection </a></li><li id='In-Practice/2D-Game/Collisions/Collision-resolution'><a id="menu-item97" href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution">Collision resolution </a></li></ol></li><li id='In-Practice/2D-Game/Particles'><a id="menu-item89" href="https://learnopengl.com/In-Practice/2D-Game/Particles">Particles </a></li><li id='In-Practice/2D-Game/Postprocessing'><a id="menu-item90" href="https://learnopengl.com/In-Practice/2D-Game/Postprocessing">Postprocessing </a></li><li id='In-Practice/2D-Game/Powerups'><a id="menu-item91" href="https://learnopengl.com/In-Practice/2D-Game/Powerups">Powerups </a></li><li id='In-Practice/2D-Game/Audio'><a id="menu-item94" href="https://learnopengl.com/In-Practice/2D-Game/Audio">Audio </a></li><li id='In-Practice/2D-Game/Render-text'><a id="menu-item92" href="https://learnopengl.com/In-Practice/2D-Game/Render-text">Render text </a></li><li id='In-Practice/2D-Game/Final-thoughts'><a id="menu-item93" href="https://learnopengl.com/In-Practice/2D-Game/Final-thoughts">Final thoughts </a></li></ol></li></ol></li><li id='Guest-Articles'><span id="menu-item125" class="closed">Guest Articles </span><ol id="menu-items-of125" style="display:none;"><li id='Guest-Articles/How-to-publish'><a id="menu-item126" href="https://learnopengl.com/Guest-Articles/How-to-publish">How to publish </a></li><li id='Guest-Articles/2020'><span id="menu-item128" class="closed">2020 </span><ol id="menu-items-of128" style="display:none;"><li id='Guest-Articles/2020/OIT'><span id="menu-item129" class="closed">OIT </span><ol id="menu-items-of129" style="display:none;"><li id='Guest-Articles/2020/OIT/Introduction'><a id="menu-item130" href="https://learnopengl.com/Guest-Articles/2020/OIT/Introduction">Introduction </a></li><li id='Guest-Articles/2020/OIT/Weighted-Blended'><a id="menu-item132" href="https://learnopengl.com/Guest-Articles/2020/OIT/Weighted-Blended">Weighted Blended </a></li></ol></li><li id='Guest-Articles/2020/Skeletal-Animation'><a id="menu-item131" href="https://learnopengl.com/Guest-Articles/2020/Skeletal-Animation">Skeletal Animation </a></li></ol></li><li id='Guest-Articles/2021'><span id="menu-item133" class="closed">2021 </span><ol id="menu-items-of133" style="display:none;"><li id='Guest-Articles/2021/CSM'><a id="menu-item137" href="https://learnopengl.com/Guest-Articles/2021/CSM">CSM </a></li><li id='Guest-Articles/2021/Scene'><span id="menu-item134" class="closed">Scene </span><ol id="menu-items-of134" style="display:none;"><li id='Guest-Articles/2021/Scene/Scene-Graph'><a id="menu-item135" href="https://learnopengl.com/Guest-Articles/2021/Scene/Scene-Graph">Scene Graph </a></li><li id='Guest-Articles/2021/Scene/Frustum-Culling'><a id="menu-item136" href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">Frustum Culling </a></li></ol></li><li id='Guest-Articles/2021/Tessellation'><span id="menu-item138" class="closed">Tessellation </span><ol id="menu-items-of138" style="display:none;"><li id='Guest-Articles/2021/Tessellation/Height-map'><a id="menu-item139" href="https://learnopengl.com/Guest-Articles/2021/Tessellation/Height-map">Height map </a></li></ol></li></ol></li></ol></li><li id='Code-repository'><a id="menu-item99" href="https://learnopengl.com/Code-repository">Code repository </a></li><li id='Translations'><a id="menu-item119" href="https://learnopengl.com/Translations">Translations </a></li><li id='About'><a id="menu-item2" href="https://learnopengl.com/About">About </a></li></ol>		<div id="menu_book">
            <a href="https://geni.us/learnopengl" target="_blank"><img src="/book/below_menu.png" class="clean"/></a>
        </div>
       <div id="donate">
            <a href="https://www.paypal.me/learnopengl/" target="_blank">
                <div id="donate_img"></div>
                <img style="display: none" src="/img/donate_button_hover.png"/>
                <!--<img id="donate_img" src="img/patreon.png"/>-->
            </a>
          <!--<div id="alipay">
            <img style="width: 150px;" class="clean" src="/img/alipay_logo.png"/>
            <img style="width: 150px; margin-top: 5px" src="/img/alipay.png"/>
          </div>-->
        </div> 
		<!--
		<div class="btc">
			<h3>BTC</h3>
			<p>
				1CLGKgmBSuYJ1nnvDGAepVTKNNDpUjfpRa
			</p>
			<img src="/img/btc_qr.png"/>
        </div> 
		<div class="btc">
			<h3>ETH/ERC20</h3>
			<p>
				0x1de59bd9e52521a46309474f8372531533bd7c43
			</p>
			<img src="/img/erc20_qr.png"/>
        </div>       
		!-->
        <div id="ad">
							<!--<div id="waldo-tag-1684"></div>-->
			        </div>
      
        <div id="lefttwothirdad">
            <div id="waldo-tag-2245"></div>
        </div>
    </div>
    
    <div id="content">
    <h1 id="content-title">Blending</h1>
<h1 id="content-url" style='display:none;'>Advanced-OpenGL/Blending</h1>
<p>
  <def>Blending</def> in OpenGL is commonly known as the technique to implement <def>transparency</def> within objects. Transparency is all about objects (or parts of them) not having a solid color, but having a combination of colors from the object itself and any other object behind it with varying intensity. A colored glass window is a transparent object; the glass has a color of its own, but the resulting color contains the colors of all the objects behind the glass as well. This is also where the name blending comes from, since we <def>blend</def> several pixel colors (from different objects) to a single color. Transparency thus allows us to see through objects.
</p>

<img src="/img/advanced/blending_transparency.png" class="clean" alt="Image of full transparent window and partially transparent window"/>

<p>
  Transparent objects can be completely transparent (letting all colors through) or partially transparent (letting colors through, but also some of its own colors). The amount of transparency of an object is defined by its color's <def>alpha</def> value. The alpha color value is the 4th component of a color vector that you've probably seen quite often now. Up until this chapter, we've always kept this 4th component at a value of <code>1.0</code> giving the object <code>0.0</code> transparency. An alpha value of <code>0.0</code> would result in the object having complete transparency. An alpha value of <code>0.5</code> tells us the object's color consist of 50% of its own color and 50% of the colors behind the object.
</p>

<p>
  The textures we've used so far all consisted of <code>3</code> color components: red, green and blue, but some textures also have an embedded alpha channel that contains an <def>alpha</def> value per texel. This alpha value tells us exactly which parts of the texture have transparency and by how much. For example, the following <a href="/img/advanced/blending_transparent_window.png" target="_blank">window texture</a> has an alpha value of <code>0.25</code> at its glass part and an alpha value of <code>0.0</code> at its corners. The glass part would normally be completely red, but since it has 75% transparency it largely shows the page's background through it, making it seem a lot less red:
</p>

<img src="/img/advanced/blending_transparent_window.png" class="clean" alt="Texture image of window with transparency"/>

<p>
  We'll soon be adding this windowed texture to the scene from the depth testing chapter, but first we'll discuss an easier technique to implement transparency for pixels that are either fully transparent or fully opaque.
</p>

<h2>Discarding fragments</h2>
<p>
  Some effects do not care about partial transparency, but either want to show something or nothing at all based on the color value of a texture. Think of grass; to create something like grass with little effort you generally paste a grass texture onto a 2D quad and place that quad into your scene. However, grass isn't exactly shaped like a 2D square so you only want to display some parts of the grass texture and ignore the others.
</p>

<p>
  The following <a href="/img/textures/grass.png" target="_blank">texture</a> is exactly such a texture where it either is full opaque (an alpha value of <code>1.0</code>) or it is fully transparent (an alpha value of <code>0.0</code>) and nothing in between. You can see that wherever there is no grass, the image shows the page's background color instead of its own.
</p>

<img src="/img/textures/grass.png" class="clean" style="width:384px; height:384px;" alt="Texture image of grass with transparency"/>

<p>
  So when adding vegetation to a scene we don't want to see a square image of grass, but rather only show the actual grass and see through the rest of the image. We want to <def>discard</def> the fragments that show the transparent parts of the texture, not storing that fragment into the color buffer. 
</p>

<p>
  Before we get into that we first need to learn how to load a transparent texture. To load textures with alpha values there's not much we need to change. <code>stb_image</code> automatically loads an image's alpha channel if it's available, but we do need to tell OpenGL our texture now uses an alpha channel in the texture generation procedure: 
</p>

<pre class="cpp"><code>
<function id='52'>glTexImage2D</function>(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);  
</code></pre>

<p>
  Also make sure that you retrieve all <code>4</code> color components of the texture in the fragment shader, not just the RGB components:
</p>

<pre><code>
void main()
{
    // FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);
    FragColor = texture(texture1, TexCoords);
}
</code></pre>

<p>
  Now that we know how to load transparent textures it's time to put it to the test by adding several of these leaves of grass throughout the basic scene introduced in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter.
</p>

<p>
  We create a small <code>vector</code> array where we add several <code>glm::vec3</code> vectors to represent the location of the grass leaves:
</p>

<pre><code>
vector&lt;glm::vec3&gt; vegetation;
vegetation.push_back(glm::vec3(-1.5f,  0.0f, -0.48f));
vegetation.push_back(glm::vec3( 1.5f,  0.0f,  0.51f));
vegetation.push_back(glm::vec3( 0.0f,  0.0f,  0.7f));
vegetation.push_back(glm::vec3(-0.3f,  0.0f, -2.3f));
vegetation.push_back(glm::vec3( 0.5f,  0.0f, -0.6f));  
</code></pre>

<p>
  Each of the grass objects is rendered as a single quad with the grass texture attached to it. It's not a perfect 3D representation of grass, but it's a lot more efficient than loading and rendering a large number of complex models. With a few tricks like adding randomized rotations and scales you can get pretty convincing results with quads.
</p>

<p>
Because the grass texture is going to be displayed on a quad object we'll need to create another VAO again, fill the VBO, and set the appropriate vertex attribute pointers. Then after we've rendered the floor and the two cubes we're going to render the grass leaves:
</p>

<pre><code>
<function id='27'>glBindVertexArray</function>(vegetationVAO);
<function id='48'>glBindTexture</function>(GL_TEXTURE_2D, grassTexture);  
for(unsigned int i = 0; i &lt; vegetation.size(); i++) 
{
    model = glm::mat4(1.0f);
    model = <function id='55'>glm::translate</function>(model, vegetation[i]);				
    shader.setMat4("model", model);
    <function id='1'>glDrawArrays</function>(GL_TRIANGLES, 0, 6);
}  
</code></pre>

<p>
  Running the application will now look a bit like this:
</p>

<img src="/img/advanced/blending_no_discard.png" class="clean" alt="Not discarding transparent parts of texture results in weird artifacts in OpenGL"/>

<p>
  This happens because OpenGL by default does not know what to do with alpha values, nor when to discard them. We have to manually do this ourselves. Luckily this is quite easy thanks to the use of shaders. GLSL gives us the  <code>discard</code> command that (once called) ensures the fragment will not be further processed and thus not end up into the color buffer. Thanks to this command we can check whether a fragment has an alpha value below a certain threshold and if so, discard the fragment as if it had never been processed:
</p>

<pre><code>
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D texture1;

void main()
{             
    vec4 texColor = texture(texture1, TexCoords);
    if(texColor.a &lt; 0.1)
        discard;
    FragColor = texColor;
}
</code></pre>


<p>
  Here we check if the sampled texture color contains an alpha value lower than a threshold of <code>0.1</code> and if so, discard the fragment. This fragment shader ensures us that it only renders fragments that are not (almost) completely transparent. Now it'll look like it should:
</p>


<img src="/img/advanced/blending_discard.png" class="clean" alt="Image of grass leaves rendered with fragment discarding in OpenGL"/>

<note>
  Note that when sampling textures at their borders, OpenGL interpolates the border values with the next repeated value of the texture (because we set its wrapping parameters to <var>GL_REPEAT</var> by default). This is usually okay, but since we're using transparent values, the top of the texture image gets its transparent value interpolated with the bottom border's solid color value. The result is then a slightly semi-transparent colored border you may see wrapped around your textured quad. To prevent this, set the texture wrapping method to <var>GL_CLAMP_TO_EDGE</var> whenever you use alpha textures that you don't want to repeat:

<pre><code>
<function id='15'>glTexParameter</function>i( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);	
<function id='15'>glTexParameter</function>i( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);    
</code></pre>
</note>

<p>
  You can find the source code <a href="/code_viewer_gh.php?code=src/4.advanced_opengl/3.1.blending_discard/blending_discard.cpp" target="_blank">here</a>.
</p>


<h2>Blending</h2>
<p>
  While discarding fragments is great and all, it doesn't give us the flexibility to render semi-transparent images; we either render the fragment or completely discard it. To render images with different levels of transparency we have to enable <def>blending</def>. Like most of OpenGL's functionality we can enable blending by enabling <var>GL_BLEND</var>:
</p>

<pre><code>
<function id='60'>glEnable</function>(GL_BLEND);  
</code></pre>

<p>
  Now that we've enabled blending we need to tell OpenGL <strong>how</strong> it should actually blend.
</p>

<p>
  Blending in OpenGL happens with the following equation:
</p>

\begin{equation}\bar{C}_{result} = \bar{\color{green}C}_{source} * \color{green}F_{source} + \bar{\color{red}C}_{destination} * \color{red}F_{destination}\end{equation}

<ul>
  <li>\(\bar{\color{green}C}_{source}\): the source color vector. This is the color output of the fragment shader.</li>
  <li>\(\bar{\color{red}C}_{destination}\): the destination color vector. This is the color vector that is currently stored in the color buffer.</li>
  <li>\(\color{green}F_{source}\): the source factor value. Sets the impact of the alpha value on the source color.</li>
  <li>\(\color{red}F_{destination}\): the destination factor value. Sets the impact of the alpha value on the destination color.</li>  
</ul>

<p>
  After the fragment shader has run and all the tests have passed, this <def>blend equation</def> is let loose on the fragment's color output and with whatever is currently in the color buffer. The source and destination colors will automatically be set by OpenGL, but the source and destination factor can be set to a value of our choosing. Let's start with a simple example:
</p>

<img src="/img/advanced/blending_equation.png" class="clean" alt="Two squares where one has alpha value lower than 1"/>

<p>
  We have two squares where we want to draw the semi-transparent green square on top of the red square. The red square will be the destination color (and thus should be first in the color buffer) and we are now going to draw the green square over the red square.
</p>

<p>
  The question then arises: what do we set the factor values to? Well, we at least want to multiply the green square with its alpha value so we want to set the \(F_{src}\) equal to the alpha value of the source color vector which is <code>0.6</code>. Then it makes sense to let the destination square have a contribution equal to the remainder of the alpha value. If the green square contributes 60% to the final color we want the red square to contribute 40% of the final color e.g. <code>1.0 - 0.6</code>. So we set \(F_{destination}\) equal to one minus the alpha value of the source color vector. The equation thus becomes:
</p>

\begin{equation}\bar{C}_{result} = \begin{pmatrix} \color{red}{0.0} \\ \color{green}{1.0} \\ \color{blue}{0.0} \\ \color{purple}{0.6} \end{pmatrix} * \color{green}{0.6} + \begin{pmatrix} \color{red}{1.0} \\ \color{green}{0.0} \\ \color{blue}{0.0} \\ \color{purple}{1.0} \end{pmatrix} * (\color{red}{1 - 0.6}) \end{equation}

<p>
  The result is that the combined square fragments contain a color that is 60% green and 40% red:
</p>

<img src="/img/advanced/blending_equation_mixed.png" class="clean" alt="Two containers where one has alpha value lower than 1"/>

<p>
  The resulting color is then stored in the color buffer, replacing the previous color. 
</p>

<p>
  So this is great and all, but how do we actually tell OpenGL to use factors like that? Well it just so happens that there is a function for this called <fun><function id='70'>glBlendFunc</function></fun>.
</p>

<p>
  The <fun><function id='70'>glBlendFunc</function>(GLenum sfactor, GLenum dfactor)</fun> function expects two parameters that set the option for the <def>source</def> and <def>destination factor</def>. OpenGL defined quite a few options for us to set of which we'll list the most common options below. Note that the constant color vector \(\bar{\color{blue}C}_{constant}\) can be separately set via the <fun><function id='73'>glBlendColor</function></fun> function. 
</p>

<table>
  <tr>
  	<th>Option</th>
  	<th>Value</th>
  </tr>  
  <tr>
    <td><code>GL_ZERO</code></td>
    <td>Factor is equal to \(0\).</td>
  </tr>
  <tr>
    <td><code>GL_ONE</code></td>
 	<td>Factor is equal to \(1\).</td>
  </tr>
  <tr>
    <td><code>GL_SRC_COLOR</code></td>
 	<td>Factor is equal to the source color vector \(\bar{\color{green}C}_{source}\).</td>
  </tr>
  <tr>
    <td><code>GL_ONE_MINUS_SRC_COLOR</code></td>
 	<td>Factor is equal to \(1\) minus the source color vector: \(1 - \bar{\color{green}C}_{source}\). </td>
  </tr><tr>
    <td><code>GL_DST_COLOR</code></td>
 	<td>Factor is equal to the destination color vector \(\bar{\color{red}C}_{destination}\)</td>
  </tr> 
  <tr>
    <td><code>GL_ONE_MINUS_DST_COLOR</code></td>
 	<td>Factor is equal to \(1\) minus the destination color vector: \(1 - \bar{\color{red}C}_{destination}\).</td>
  </tr>
  <tr>
    <td><code>GL_SRC_ALPHA</code></td>
 	<td>Factor is equal to the \(alpha\) component of the source color vector \(\bar{\color{green}C}_{source}\).  </td>
  </tr>
  <tr>
    <td><code>GL_ONE_MINUS_SRC_ALPHA</code></td>
 	<td>Factor is equal to \(1 - alpha\) of the source color vector \(\bar{\color{green}C}_{source}\).</td>
  </tr>
  <tr>
    <td><code>GL_DST_ALPHA</code></td>
 	<td>Factor is equal to the \(alpha\) component of the destination color vector \(\bar{\color{red}C}_{destination}\).  </td>
  </tr>
  <tr>
    <td><code>GL_ONE_MINUS_DST_ALPHA</code></td>
 	<td>Factor is equal to \(1 - alpha\) of the destination color vector \(\bar{\color{red}C}_{destination}\).</td>
  </tr>
  <tr>
    <td><code>GL_CONSTANT_COLOR</code></td>
 	<td>Factor is equal to the constant color vector \(\bar{\color{blue}C}_{constant}\).  </td>
  </tr>
  <tr>
    <td><code>GL_ONE_MINUS_CONSTANT_COLOR</code></td>
 	<td>Factor is equal to \(1\) - the constant color vector \(\bar{\color{blue}C}_{constant}\).</td>
  </tr>
  <tr>
    <td><code>GL_CONSTANT_ALPHA</code></td>
 	<td>Factor is equal to the \(alpha\) component of the constant color vector \(\bar{\color{blue}C}_{constant}\).  </td>
  </tr>
  <tr>
    <td><code>GL_ONE_MINUS_CONSTANT_ALPHA</code></td>
 	<td>Factor is equal to \(1 - alpha\) of the constant color vector \(\bar{\color{blue}C}_{constant}\).</td>
  </tr>
</table>

<p>
  To get the blending result of our little two square example, we want to take the \(alpha\) of the source color vector for the source factor and \(1 - alpha\) of the same color vector for the destination factor. This translates to <fun><function id='70'>glBlendFunc</function></fun> as follows:
</p>

<pre><code>
<function id='70'>glBlendFunc</function>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);  
</code></pre>

<p>
  It is also possible to set different options for the RGB and alpha channel individually using <fun><function id='71'><function id='70'>glBlendFunc</function>Separate</function></fun>:
</p>

<pre><code>
<function id='71'><function id='70'>glBlendFunc</function>Separate</function>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
</code></pre>

<p>
  This function sets the RGB components as we've set them previously, but only lets the resulting alpha component be influenced by the source's alpha value.
</p>

<p>
  OpenGL gives us even more flexibility by allowing us to change the operator between the source and destination part of the equation. Right now, the source and destination components are added together, but we could also subtract them if we want. <fun><function id='72'>glBlendEquation</function>(GLenum mode)</fun> allows us to set this operation and has 5 possible options:
</p>

<ul>
  <li><code>GL_FUNC_ADD</code>: the default, adds both colors to each other: \(\bar{C}_{result} = \color{green}{Src} + \color{red}{Dst}\).</li>
  <li><code>GL_FUNC_SUBTRACT</code>: subtracts both colors from each other: \(\bar{C}_{result} = \color{green}{Src} - \color{red}{Dst}\).</li>
  <li><code>GL_FUNC_REVERSE_SUBTRACT</code>: subtracts both colors, but reverses order: \(\bar{C}_{result} = \color{red}{Dst} - \color{green}{Src}\).</li>
  <li><code>GL_MIN</code>: takes the component-wise minimum of both colors: \(\bar{C}_{result} = min(\color{red}{Dst}, \color{green}{Src})\).</li>
  <li><code>GL_MAX</code>: takes the component-wise maximum of both colors: \(\bar{C}_{result} = max(\color{red}{Dst}, \color{green}{Src})\).</li>
</ul>

<p>
  Usually we can simply omit a call to <fun><function id='72'>glBlendEquation</function></fun> because <var>GL_FUNC_ADD</var> is the preferred blending equation for most operations, but if you're really trying your best to break the mainstream circuit any of the other equations could suit your needs.
</p>

<h2>Rendering semi-transparent textures</h2>
<p>
  Now that we know how OpenGL works with regards to blending it's time to put our knowledge to the test by adding several semi-transparent windows. We'll be using the same scene as in the start of this chapter, but instead of rendering a grass texture we're now going to use the <a href="/img/advanced/blending_transparent_window.png" target="_blank">transparent window</a> texture from the start of this chapter.
</p>

<p>
  First, during initialization we enable blending and set the appropriate blending function:
</p>

<pre><code>
<function id='60'>glEnable</function>(GL_BLEND);
<function id='70'>glBlendFunc</function>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);  
</code></pre>

<p>
  Since we enabled blending there is no need to discard fragments so we'll reset the fragment shader to its original version:
</p>

<pre><code>
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D texture1;

void main()
{             
    FragColor = texture(texture1, TexCoords);
}  
</code></pre>

<p>
  This time (whenever OpenGL renders a fragment) it combines the current fragment's color with the fragment color currently in the color buffer based on the alpha value of <var>FragColor</var>. Since the glass part of the window texture is semi-transparent we should be able to see the rest of the scene by looking through this window.
</p>


<img src="/img/advanced/blending_incorrect_order.png" class="clean" alt="A blended scene in OpenGL where order is incorrect."/>

<p>
  If you take a closer look however, you may notice something is off. The transparent parts of the front window are occluding the windows in the background. Why is this happening?
</p>

<p>
  The reason for this is that depth testing works a bit tricky combined with blending. When writing to the depth buffer, the depth test does not care if the fragment has transparency or not, so the transparent parts are written to the depth buffer as any other value. The result is that the background windows are tested on depth as any other opaque object would be, ignoring transparency. Even though the transparent part should show the windows behind it, the depth test discards them.
</p>

<p>
  So we cannot simply render the windows however we want and expect the depth buffer to solve all our issues for us; this is also where blending gets a little nasty. To make sure the windows show the windows behind them, we have to draw the windows in the background first. This means we have to manually sort the windows from furthest to nearest and draw them accordingly ourselves.
</p>

<note>
  Note that with fully transparent objects like the grass leaves we have the option to discard the transparent fragments instead of blending them, saving us a few of these headaches (no depth issues).
</note>

<h2>Don't break the order</h2>
<p>
  To make blending work for multiple objects we have to draw the most distant object first and the closest object last. The normal non-blended objects can still be drawn as normal using the depth buffer so they don't have to be sorted. We do have to make sure they are drawn first before drawing the (sorted) transparent objects. When drawing a scene with non-transparent and transparent objects the general outline is usually as follows:
</p>

<ol>
  <li>Draw all opaque objects first.</li>
  <li>Sort all the transparent objects.</li>
  <li>Draw all the transparent objects in sorted order.</li>
</ol>

<p>
  One way of sorting the transparent objects is to retrieve the distance of an object from the viewer's perspective. This can be achieved by taking the distance between the camera's position vector and the object's position vector. We then store this distance together with the corresponding position vector in a <fun>map</fun> data structure from the STL library. A <fun>map</fun> automatically sorts its values based on its keys, so once we've added all positions with their distance as the key they're automatically sorted on their distance value:
</p>

<pre><code>
std::map&lt;float, glm::vec3&gt; sorted;
for (unsigned int i = 0; i &lt; windows.size(); i++)
{
    float distance = glm::length(camera.Position - windows[i]);
    sorted[distance] = windows[i];
}
</code></pre>

<p>
  The result is a sorted container object that stores each of the window positions based on their <var>distance</var> key value from lowest to highest distance.
</p>

<p>
  Then, this time when rendering, we take each of the map's values in reverse order (from farthest to nearest) and then draw the corresponding windows in correct order:
</p>

<pre><code>
for(std::map&lt;float,glm::vec3&gt;::reverse_iterator it = sorted.rbegin(); it != sorted.rend(); ++it) 
{
    model = glm::mat4(1.0f);
    model = <function id='55'>glm::translate</function>(model, it-&gt;second);				
    shader.setMat4("model", model);
    <function id='1'>glDrawArrays</function>(GL_TRIANGLES, 0, 6);
}  
</code></pre>

<p>
  We take a reverse iterator from the <fun>map</fun> to iterate through each of the items in reverse order and then translate each window quad to the corresponding window position. This relatively simple approach to sorting transparent objects fixes the previous problem and now the scene looks like this:
</p>

<img src="/img/advanced/blending_sorted.png" class="clean" alt="Image of an OpenGL scene with blending enabled, objects are sorted from far to near"/>

<p>
  You can find the complete source code with sorting <a href="/code_viewer_gh.php?code=src/4.advanced_opengl/3.2.blending_sort/blending_sorted.cpp" target="_blank">here</a>.
</p>

<p>
  While this approach of sorting the objects by their distance works well for this specific scenario, it doesn't take rotations, scaling or any other transformation into account and weirdly shaped objects need a different metric than simply a position vector. 
</p>

<p>
  Sorting objects in your scene is a difficult feat that depends greatly on the type of scene you have, let alone the extra processing power it costs. Completely rendering a scene with solid and transparent objects isn't all that easy. There are more advanced techniques like <def>order independent transparency</def> but these are out of the scope of this chapter. For now you'll have to live with normally blending your objects, but if you're careful and know the limitations you can get pretty decent blending implementations.
</p>
       

    </div>
    
    <div id="hover">
        HI
    </div>
   <!-- 728x90/320x50 sticky footer -->
<!--<div id="waldo-tag-6196"></div>-->

   <div id="disqus_thread"></div>

    


</div> <!-- container div -->


</div> <!-- super container div -->
</body>
</html>